Убедитесь, что EF Core будет работать с вашим приложением
=========================================================

Перед тем, как начать процесс портирования важно проверить, что EF Core отвечает требованиям доступа к данным вашего приложения.

.. contents:: `В этой статье:`
    :depth: 2
    :local:

Недостающие функции
-------------------

Убедитесь, что в EF Core есть все функции, необходимые для использования в приложении. Для детального сравнения набора функций EF Core и EF6.x. смотрите раздел :doc:`/efcore-vs-ef6/features`. Если какие-либо необходимые функции отсутствуют, убедитесь, что вы можете компенсировать отсутствие этих функций, прежде чем портировать на EF Core.


Изменения поведения
-------------------

Это не исчерпывающий перечень некоторых изменений в поведении между EF6.x и EF Core. Важно иметь это в виду при портировании вашего приложения, поскольку после замены на EF Core поведение приложения может измениться, но ошибки компиляции отображаться не будут.

DbSet.Add/Attach и поведения графа
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В EF6.x, в результате вызова метода ``DbSet.Add()`` сущности, происходит рекурсивный поиск всех сущностей, на которые ссылаются ее навигационные свойства. Любые найденные, но уже не отслеживаемые контекстом сущности, так же будут помечены как добавленные. ``DbSet.Attach()`` ведет себя так же, за исключением того, что все объекты помечаются как без изменений..

EF Core выполняет аналогичный рекурсивный поиск, но с некоторыми немного различными правилами.
  * Основная сущность всегда в состоянии запроса (добавляет по ``DbSet.Add`` и не изменяет по ``DbSet.Attach``).
  * Для сущностей, которые найдены во время рекурсивного поиска по навигационным свойствам:
      * Если первичный ключ сущности сгенерирован в хранилище
          * Если в первичном ключе не установлено значение, состояние изменяется на "добавлено". Значение первичного ключа считается "не установлено" если ему назначено значение свойства по умолчанию соответствующего типа CLR (например ``0`` для ``int``, ``null`` для ``string``, и т.д.).
          * Если значение первичного ключа установлено, то состояние устанавливается в "неизменяемое".
      * Если первичный ключ сгенерирован не в базе данных, то сущность записывается в том же самом состоянии, как и основная.

Инициализация базы данных Code First
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EF6.x имеет значительное количество магии, которую он выполняет вокруг выбора подключения к базе данных и инициализации базы данных. Некоторые из этих правил включают в себя:
  * Если настройка не выполнена, EF6.x выберет базу данных на SQL Express или LocalDb.
  * Если строка подключения с тем же именем, что и контекст в файле приложения ``App/Web.config``, будет использоваться это соединение.
  * Если базы данных нет, она будет создана.
  * Если в базе данных нет таблиц из модели, то в базу данных добавляется схема для текущей модели. Если включены миграций, то они используются для создания базы данных.
  * Если база данных существует и ранее EF6.x создал схемы, схема проверяется для совместимости с текущей моделью. Если модель изменилась с момента создания схемы - бросается исключение.

EF Core не выполняет такую магию.
  * Подключение к базе данных должно быть явно настроено в коде.
  * Не выполняется инициализация. Вы можете использовать ``DbContext.Database.Migrate()`` для применения миграций (или ``DbContext.Database.EnsureCreated()`` и ``EnsureDeleted()`` для создания/удаления базы данных без использования миграций).

Соглашения наименования таблиц Code First
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для вычисления имени таблицы по умолчанию, которая связана с сущностью, EF6.x работает с именем класса сущности через службу плюрализации.

EF Core использует имя свойства ``DbSet``, которое используется сущностью в качестве производного контекста. Если у сущности нет свойства ``DbSet``, то используется имя класса.
