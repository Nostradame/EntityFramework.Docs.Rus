Отношения
=============

Отношения определяют, как две сущности связаны друг с другом. В реляционной базе данных это представлено ограничением при помощи внешнего ключа.

.. note::
    Большинство примеров в этой статье для демонстрации концепции используют отношение **один-ко-многим**. Примеры отношений **один-к-одному** и **многие-ко-многим** смотрите в разделе `Другие модели отношений`_ в конце статьи.

.. contents:: В этой статье:
    :depth: 3

Значение терминов
-------------------------

Есть целый ряд терминов, используемых для описания отношений
 - **Зависимая сущность:** Это объект, который содержит свойство внешнего ключа(ключей). В отношениях иногда упоминается как «потомок».
 - **Основная сущность:** Это объект, который содержит свойства первичного / альтернативного ключа(ключей). В отношениях иногда упоминается как «родитель».
 - **Внешний ключ:** Свойство(свойства) в зависимой сущности, которое используется для хранения значений свойства главного ключа сущности, к которой относится объект.
 - **Главный ключ:** Свойство(свойства), которое однозначно идентифицирует основную сущность. Это может быть первичный ключ или альтернативный ключ.
 - **Навигационное свойство:** это свойство, определяющее основную и/или зависимую сущность, которое содержит ссылку(ссылки) на соответственную сущность(сущности).
 - **Коллекция навигационных свойств:** это навигационное свойство, содержащее ссылки на несколько соответствующих сущностей.
 - **Ссылочное навигационное свойство:** навигационное свойство, которое содержит ссылку на одну соответствующую сущность.
 - **Обратное навигационное свойство:** При обсуждении конкретного свойство навигации, этот термин относится к навигационному свойству на другом конце отношений.

Следующий код показывает отношение **один-ко-многим** между ``Blog`` и ``Post``
  - ``Post`` это зависимая сущность
  - ``Blog`` это основная сущность
  - ``Post.BlogId`` является внешним ключом
  - ``Blog.BlogId`` это главный ключ (в данном случае это первичный ключ, а не альтернативный ключ)
  - ``Post.Blog`` это ссылочное навигационное свойство
  - ``Blog.Posts`` это коллекция навигационных свойств
  - ``Post.Blog`` это обратное навигационное свойство сущности ``Blog.Posts`` (и наоборот)

.. includesamplefile:: Modeling/Conventions/Samples/Relationships/Full.cs
        :language: c#
        :lines: 12-28
        :linenos:

Соглашения
---------------

По соглашению, отношения будут созданы, если в типе обнаружено навигационное свойство. Свойство считается навигационным, если тип, на который оно указывает, не может быть отображен текущим поставщиком базы данных в виде скалярного типа.

.. note::
    Отношения, которые обнаруживаются по соглашению, всегда будут направлены ​​на первичный ключ основного объекта. Чтобы настроить таргетинг на альтернативный ключ, должна быть выполнена дополнительная конфигурация с использованием Fluent API.

Полностью определенные отношения
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Наиболее распространенный паттерн отношений это наличие навигационных свойств, определенных на обоих концах отношений, а так же свойство внешнего ключа, определенное в классе зависимой сущности.
 - Если между двумя типами найдена пара навигационных свойств, то они будут сконфигурированы как обратные навигационные свойства одного и того же отношения.
 - Если зависимый объект содержит свойство с именем ``<имя свойства первичного ключа>``, ``<имя навигационного свойства><имя свойства первичного ключа>``, или ``<имя основной сущности><имя свойства первичного ключа>`` то оно будет определено в качестве внешнего ключа..

.. includesamplefile:: Modeling/Conventions/Samples/Relationships/Full.cs
       :language: c#
       :lines: 12-28
       :emphasize-lines: 6, 15-16
       :linenos:

.. attention::
    Если есть несколько навигационных свойств, определенных между двумя типами (т.е. есть более одной навигационной пары, которые указывают друг на друга), то в соответствии с соглашениями, не будет создано никаких отношений, и вам нужно будет вручную сконфигурировать их чтобы определить пары наигационных свойств.

Без свойства внешнего ключа
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Хотя и рекомендуется иметь свойство внешнего ключа, определенное в классе зависимой сущности, но это не обязательно. Если свойство внешнего ключа не найдено, будет введено скрытое свойство внешнего ключа с именем ``<имя навигационного свойства><имя свойства основного ключа>`` (более подробно смотрите раздел :doc:`shadow-properties`).

.. includesamplefile:: Modeling/Conventions/Samples/Relationships/NoForeignKey.cs
        :language: c#
        :lines: 12-27
        :emphasize-lines: 6, 15
        :linenos:

Простое навигационное свойство
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Чтобы возникли отношения, определенные в соответствии с соглашением, достаточно только одного навигационного свойства (без обратной навигации, и без свойства внешнего ключа). У вас так же может быть одно свойство навигации и свойство внешнего ключа.

.. includesamplefile:: Modeling/Conventions/Samples/Relationships/OneNavigation.cs
        :language: c#
        :lines: 12-25
        :emphasize-lines: 6
        :linenos:

Каскадное удаление
^^^^^^^^^^^^^^^^^^^^

По соглашению, каскадное удаление будет установлено в *Cascade* для обязательных отношений и в *SetNull* для необязательных. *Cascade* означает, что зависимые объекты также будут удалены. *SetNull* означает, что свойства внешнего ключа в зависимых сущностях устанавливаются в null.

.. note::
    Такое каскадное поведение применяется только к сущностям, которые отслеживаются контекстом. Соответствующее каскадное поведение должно быть установлено в базе данных, чтобы гарантировать, что к данным, не отслеживаемым контекстом применяются те же действия. Если для создания базы данных вы используете EF, то для вас будет установлено такое каскадное поведение.

Аннотации данных
------------------------

Есть две аннотации данных, которые могут быть использованы для настройки отношений: ``[ForeignKey]`` и ``[InverseProperty]``.

[ForeignKey]
^^^^^^^^^^^^

Вы можете использовать аннотацию данных для настройки свойств, которые должны использоваться как внешние ключи для данных отношений. Обычно это делается, когда свойство внешнего ключа не обнаружено по соглашению.

.. includesamplefile:: Modeling/DataAnnotations/Samples/Relationships/ForeignKey.cs
        :language: c#
        :lines: 13-31
        :emphasize-lines: 17
        :linenos:

.. note::
    Аннотация ``[ForeignKey]`` может быть размещена над любым навигационным свойством в отношениях. Для этого не нужно переходить на навигационные свойства в классе зависимой сущности.

[InverseProperty]
^^^^^^^^^^^^^^^^^

Вы можете использовать аннотации данных для настройки того, как определяются зависимые и главные навигационные свойства для пары сущностей . Обычно это делается когда есть более чем одна пара навигационных свойствмежду двумя типами сущностей.

.. includesamplefile:: Modeling/DataAnnotations/Samples/Relationships/InverseProperty.cs
        :language: c#
        :lines: 13-37
        :emphasize-lines: 20,23
        :linenos:

Fluent API
-------------------

Для настройки отношений в Fluent API, вы начинаете с идентификации навигационных свойств, которые создают отношения. ``HasOne`` или ``HasMany`` идентифицируют навигационные свойства типа сущности, с которых начинается навигация. Затем вы поэтапно вызываете ``WithOne`` или ``WithMany`` чтобы идентифицировать обратную навигацию. ``HasOne``/``WithOne`` используется для ссылки на свойство навигации, а ``HasMany``/``WithMany`` используется для коллекции навигационных свойств.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/NoForeignKey.cs
        :language: c#
        :lines: 6-34
        :emphasize-lines: 8-10
        :linenos:

Простое навигационное свойство
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если у вас есть только одно навигационное свойство, то перегрузки без параметров ``WithOne`` и ``WithMany``. Это указывает на то, что концептуально существует ссылка или коллекция на другом конце отношений, но в классе сущностей нет свойства навигации.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/OneNavigation.cs
        :language: c#
        :lines: 6-32
        :emphasize-lines: 10
        :linenos:

Внешний ключ
^^^^^^^^^^^^^^^^

Вы можете использовать Fluent API для настройки свойств, которые должны использоваться как внешние ключи для данных отношений.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/ForeignKey.cs
        :language: c#
        :lines: 6-36
        :emphasize-lines: 11
        :linenos:

Следующий код показывает, как настроить составной внешний ключ.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/CompositeForeignKey.cs
        :language: c#
        :lines: 7-42
        :emphasize-lines: 13
        :linenos:

Главный ключ
^^^^^^^^^^^^^^^^

Если для отношения требуется внешний ключ для ссылки на свойство отличающийся от первичного ключа, можно использовать Fluent API для настройки свойства Principal Key. Свойство, которое вы сконфигурируете как главный ключ будет автоматически установлено как альтернативный ключ (более подробно смотрите :doc:`alternate-keys`).

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/PrincipalKey.cs
        :language: c#
        :lines: 7-39
        :emphasize-lines: 11
        :linenos:

Следующий код показывает, как настроить составной главный ключ.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/CompositePrincipalKey.cs
        :language: c#
        :lines: 7-41
        :emphasize-lines: 11
        :linenos:

.. attention::
    Порядок, в котором вы определили свойства главного ключа должен соответствовать порядку в котором указаны внешние ключи.

Required
^^^^^^^^

Вы можете использовать Fluent API для настройки как обязательных отношений, так и необязательных. В конечном итоге это управляет тем, является ли свойство внешнего ключа обязательным или необязательным. Это особенно полезно, когда вы используете скрытое состояние внешнего ключа. Если у вас в классе сущностей есть свойство внешнего ключа, то необходимость отношения определяется на основе того, является ли свойство внешнего ключа обязательным или необязательным (для получения дополнительной информации смотрите :doc:`required-optional`).

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/Required.cs
        :language: c#
        :lines: 6-35
        :emphasize-lines: 11
        :linenos:

Каскадное удаление
^^^^^^^^^^^^^^^^^^^^

Вы можете использовать Fluent API для настройки поведения каскадного удаления для данных отношений.

Есть три модели поведения, которые управляют тем, как применяется операция удаления зависимых сущностей в оношениях, когда главный удаляется или разорвал отношения.
 - **Cascade:** Зависимые сущности также будут удалены.
 - **SetNull:** Свойства внешнего ключа в зависимых сущностях устанавливаются в значение null.
 - **Restrict:** Операция удаления не применяется к зависимой сущности. Зависимые сущности остаются неизменными.

.. note::
    Такое каскадное поведение применяется только к сущностям, которые отслеживаются контекстом. Соответствующее каскадное поведение должно быть установлено в базе данных, чтобы гарантировать, что к данным, не отслеживаемым контекстом применяются те же действия. Если для создания базы данных вы используете EF, то для вас будет установлено такое каскадное поведение.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/CascadeDelete.cs
        :language: c#
        :lines: 7-37
        :emphasize-lines: 11
        :linenos:

Другие модели отношений
---------------------------------

Один-к-одному
^^^^^^^^^^^^^^^^

Отношения один-к-одному имеют ссылочные навигационные свойства на обеих сторонах. Они соблюдают те же соглашения, что и один-ко-многим, но в свойство внешнего ключа вводится уникальный индекс чтобы убедиться, что одному зависящей сущности соответствует только одна главная.


.. includesamplefile:: Modeling/Conventions/Samples/Relationships/OneToOne.cs
        :language: c#
        :lines: 12-28
        :emphasize-lines: 6,15-16
        :linenos:

.. note::
    EF будет выбрать в качестве зависимого одного из субъектов, основываясь на своей способности обнаруживать свойство внешнего ключа. Если в качестве зависимого выбрана неправильная сущность, можно использовать Fluent API чтобы исправить это.

При настройке отношения при помощи Fluent API, вы используете методы ``HasOne`` и ``WithOne`` .

Когда конфигурируется внешний ключ, вам необходимо определить тип зависимой сущности - обратите внимание на общий параметр представляющий ``HasForeignKey`` в листинге ниже. В отношениях один-ко-многим понятно, что сущность с навигационной ссылкой является зависимой, а другая с соллекцией это главная. Но это не так в отношении один к одному - следовательно, необходимо явным образом определить его.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/OneToOne.cs
        :language: c#
        :lines: 6-36
        :emphasize-lines: 11
        :linenos:

Многие-ко-многим
^^^^^^^^^^^^^^^^^^

Отношения многие-ко-многим без класса сущности для представления таблицы вхождений пока не поддерживаются. Однако, вы можете представить отношения многие-ко-многим включив класс сущности в таблицу вхождений и отобразить два отдельных отношения один-ко-многим.

.. includesamplefile:: Modeling/FluentAPI/Samples/Relationships/ManyToMany.cs
        :language: c#
        :lines: 6-51
        :emphasize-lines: 11-14,16-19,39-46
        :linenos:
